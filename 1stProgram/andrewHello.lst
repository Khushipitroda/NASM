     1                                  ; program example cosc 2331
     2                                  ; author:  Dr. Laura Baker
     3                                  ; prints hello world to screen.
     4                                  ; prompts user to enter name
     5                                  ; outputs message with user name
     6                                  
     7                                  
     8                                  ; uninitialized data sectiom
     9                                   section .bss  
    10 00000000 <res 0000001E>           our_name resb 30
    11 0000001E <res 00000004>           name_len resd 1
    12 00000022 <res 00000050>           our_major resb 80
    13 00000072 <res 00000004>           major_len resd 1
    14                                  
    15                                  ;section declaration for defined data (must be initialized)
    16                                   section .data          
    17 00000000 48656C6C6F20546865-      hello_msg db "Hello There! ",10  ; the 10 is the newline(LineFeed)  
    18 00000009 726521200A         
    19                                   len1 equ $ - hello_msg            ; length of the message
    20 0000000E 576861742069732079-      prompt_name db "What is your name? "
    21 00000017 6F7572206E616D653F-
    22 00000020 20                 
    23                                   len3 equ $ - prompt_name    ; length of the prompt
    24 00000021 57656C636F6D652074-      welcome_msg db "Welcome to Nasm ",
    25 0000002A 6F204E61736D20     
    26                                   len2 equ $ - welcome_msg   ; length of the message
    27 00000031 576861742069732079-      major_prompt db "What is your major? " 
    28 0000003A 6F7572206D616A6F72-
    29 00000043 3F20               
    30                                   mlen1 equ $ - major_prompt
    31 00000045 2069732061206E6963-      major_msg db " is a nice major, unless it's not cs related..."
    32 0000004E 65206D616A6F722C20-
    33 00000057 756E6C657373206974-
    34 00000060 2773206E6F74206373-
    35 00000069 2072656C617465642E-
    36 00000072 2E2E               
    37                                   mlen2 equ $ - major_msg
    38                                   
    39 00000074 0A                       newline db  10             ; our own string for a LineFeed(LF)
    40                                  
    41                                   section .text     ;  section declaration for instructions
    42                                  
    43                                                 ;we must export the entry point to the ELF linker or
    44                                   global _start ;loader. They conventionally recognize _start as their
    45                                                 ;entry point. Use ld -e foo to override the default.
    46                                   _start:
    47                                  
    48                                    ;write our hello world message (it includes lf)
    49 00000000 BA0E000000                  mov edx,len1             ;  message length
    50 00000005 B9[00000000]                mov ecx, hello_msg       ; second argument: pointer to message to write
    51 0000000A BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    52 0000000F B804000000                  mov eax,4                ;system call number (sys_write)
    53 00000014 CD80                        int 0x80       ; call kernel to perform the interrupt (output string)
    54                                  
    55                                     ; now output prompt for name
    56 00000016 BA13000000                  mov edx,len3             ;  message length
    57 0000001B B9[0E000000]                mov ecx, prompt_name     ; second argument: pointer to message to write
    58 00000020 BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    59 00000025 B804000000                  mov eax,4                ;system call number (sys_write)
    60 0000002A CD80                        int 0x80        ; call kernel to perform the interrupt (output string)
    61                                  b1:   
    62                                     ; now read the name   
    63 0000002C BA1E000000                  mov edx, 30            ; max chars to read
    64 00000031 B9[00000000]                mov ecx, our_name     ; where to store input value
    65 00000036 BB02000000                  mov ebx, 2             ; where to read from (stdin)
    66 0000003B B803000000                  mov eax, 3             ; read 
    67 00000040 CD80                        int 0x80        ; call kernel to perform the interrupt (input string)
    68                                    
    69                                     ; now save size of string input 
    70                                     ; which is placed into the eax register by interupt
    71                                  
    72                                     ; now output prompt for major
    73 00000042 BA14000000                  mov edx,mlen1             ;  message length
    74 00000047 B9[31000000]                mov ecx, major_prompt     ; second argument: pointer to message to write
    75 0000004C BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    76 00000051 B804000000                  mov eax,4                ;system call number (sys_write)
    77 00000056 CD80                        int 0x80        ; call kernel to perform the interrupt (output string)
    78                                  b2:   
    79                                     ; now read the major
    80 00000058 BA50000000                  mov edx, 80            ; max chars to read
    81 0000005D B9[22000000]                mov ecx, our_major     ; where to store input value
    82 00000062 BB02000000                  mov ebx, 2             ; where to read from (stdin)
    83 00000067 B803000000                  mov eax, 3             ; read 
    84 0000006C CD80                        int 0x80        ; call kernel to perform the interrupt (input string)
    85                                    
    86                                     ; now save size of string input 
    87                                     ; which is placed into the eax register by interupt
    88 0000006E 48                          dec eax                ; don't count newline
    89 0000006F A3[1E000000]                mov dword [name_len], eax  
    90                                  
    91                                    ; write our first prompt string to stdout
    92 00000074 BA10000000                  mov edx,len2             ;  message length
    93 00000079 B9[21000000]                mov ecx,welcome_msg      ; second argument: pointer to message to write
    94 0000007E BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    95 00000083 B804000000                  mov eax,4                ;system call number (sys_write)
    96 00000088 CD80                        int 0x80        ; call kernel to perform the interrupt
    97                                   
    98 0000008A 8B15[1E000000]              mov edx, dword [name_len]
    99 00000090 B9[00000000]                mov ecx, our_name
   100 00000095 BB01000000                  mov ebx, 1
   101 0000009A B804000000                  mov eax, 4
   102 0000009F CD80                        int 0x80        ; call kernel to perform the interrupt
   103                                  
   104                                  
   105 000000A1 48                          dec eax                ; don't count newline
   106 000000A2 A3[72000000]                mov dword [major_len], eax  
   107                                  
   108                                    ; now print the newline
   109 000000A7 BA01000000                  mov edx, 1      		; 1 character to print
   110 000000AC B9[74000000]                mov ecx, newline            ; load address of character
   111 000000B1 BB01000000                  mov ebx, 1                  ;  ebx = 1
   112 000000B6 B804000000                  mov eax, 4                  ;  eax = 4
   113 000000BB CD80                        int 0x80        ; call kernel to perform the interrupt
   114                                  
   115 000000BD 8B15[72000000]              mov edx, dword [major_len]
   116 000000C3 B9[22000000]                mov ecx, our_major
   117 000000C8 BB01000000                  mov ebx, 1
   118 000000CD B804000000                  mov eax, 4
   119 000000D2 CD80                        int 0x80        ; call kernel to perform the interrupt
   120                                  
   121                                    ; write our first prompt string to stdout
   122 000000D4 BA2F000000                  mov edx,mlen2             ;  message length
   123 000000D9 B9[45000000]                mov ecx,major_msg      ; second argument: pointer to message to write
   124 000000DE BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
   125 000000E3 B804000000                  mov eax,4                ;system call number (sys_write)
   126 000000E8 CD80                        int 0x80        ; call kernel to perform the interrupt
   127                                   
   128                                  
   129                                    ; now print the newline
   130 000000EA BA01000000                  mov edx, 1      		; 1 character to print
   131 000000EF B9[74000000]                mov ecx, newline            ; load address of character
   132 000000F4 BB01000000                  mov ebx, 1                  ;  ebx = 1
   133 000000F9 B804000000                  mov eax, 4                  ;  eax = 4
   134 000000FE CD80                        int 0x80        ; call kernel to perform the interrupt
   135                                  
   136                                    ; now exit the program    
   137 00000100 BB00000000                  mov ebx, 0       		; the stop interrupt
   138 00000105 B801000000                  mov eax, 1                  ; eax = 0, ebx = 1
   139 0000010A CD80                        int 0x80        ; call kernel to perform the interrupt (stop)
