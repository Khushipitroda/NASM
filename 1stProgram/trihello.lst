     1                                  ; program example cosc 2331
     2                                  ; author:  Dr. Laura Baker
     3                                  ; prints hello world to screen.
     4                                  ; prompts user to enter name
     5                                  ; outputs message with user name
     6                                  
     7                                  
     8                                  ; uninitialized data sectiom
     9                                   section .bss  
    10 00000000 <res 0000001E>           our_name resb 30
    11 0000001E <res 00000004>           name_len resd 1
    12 00000022 <res 00000050>           our_major resb 80
    13 00000072 <res 00000004>           major_len resd 1
    14                                  
    15                                  ;section declaration for defined data (must be initialized)
    16                                   section .data          
    17 00000000 48656C6C6F20546865-      hello_msg db "Hello There! ",10  ; the 10 is the newline(LineFeed)  
    18 00000009 726521200A         
    19                                   len1 equ $ - hello_msg            ; length of the message
    20 0000000E 576861742069732079-      prompt_name db "What is your name? "
    21 00000017 6F7572206E616D653F-
    22 00000020 20                 
    23                                   len3 equ $ - prompt_name    ; length of the prompt
    24 00000021 57656C636F6D652074-      welcome_msg db "Welcome to Nasm ",
    25 0000002A 6F204E61736D20     
    26                                   len2 equ $ - welcome_msg   ; length of the message
    27 00000031 576861742069732079-      major_prompt db "What is your major? " 
    28 0000003A 6F7572206D616A6F72-
    29 00000043 3F20               
    30                                   mlen1 equ $ - major_prompt
    31 00000045 2069732061206E6963-      major_msg db " is a nice major, unless it's not cs related..."
    32 0000004E 65206D616A6F722C20-
    33 00000057 756E6C657373206974-
    34 00000060 2773206E6F74206373-
    35 00000069 2072656C617465642E-
    36 00000072 2E2E               
    37                                   mlen2 equ $ - major_msg
    38                                   
    39 00000074 0A                       newline db  10             ; our own string for a LineFeed(LF)
    40                                  
    41                                   section .text     ;  section declaration for instructions
    42                                  
    43                                                 ;we must export the entry point to the ELF linker or
    44                                   global _start ;loader. They conventionally recognize _start as their
    45                                                 ;entry point. Use ld -e foo to override the default.
    46                                   _start:
    47                                  
    48                                    ;write our hello world message (it includes lf)
    49 00000000 BA0E000000                  mov edx,len1             ;  message length
    50 00000005 B9[00000000]                mov ecx, hello_msg       ; second argument: pointer to message to write
    51 0000000A BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    52 0000000F B804000000                  mov eax,4                ;system call number (sys_write)
    53 00000014 CD80                        int 0x80       ; call kernel to perform the interrupt (output string)
    54                                  
    55                                     ; now output prompt for name
    56 00000016 BA13000000                  mov edx,len3             ;  message length
    57 0000001B B9[0E000000]                mov ecx, prompt_name     ; second argument: pointer to message to write
    58 00000020 BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    59 00000025 B804000000                  mov eax,4                ;system call number (sys_write)
    60 0000002A CD80                        int 0x80        ; call kernel to perform the interrupt (output string)
    61                                  b1:   
    62                                     ; now read the name   
    63 0000002C BA1E000000                  mov edx, 30            ; max chars to read
    64 00000031 B9[00000000]                mov ecx, our_name     ; where to store input value
    65 00000036 BB02000000                  mov ebx, 2             ; where to read from (stdin)
    66 0000003B B803000000                  mov eax, 3             ; read 
    67 00000040 CD80                        int 0x80        ; call kernel to perform the interrupt (input string)
    68                                    
    69                                     ; now save size of string input 
    70                                     ; which is placed into the eax register by interupt
    71 00000042 48                          dec eax                ; don't count newline
    72 00000043 A3[1E000000]                mov dword [name_len], eax  
    73                                  
    74                                    
    75                                     ; now output prompt for major
    76 00000048 BA14000000                  mov edx,mlen1             ;  message length
    77 0000004D B9[31000000]                mov ecx, major_prompt     ; second argument: pointer to message to write
    78 00000052 BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    79 00000057 B804000000                  mov eax,4                ;system call number (sys_write)
    80 0000005C CD80                        int 0x80        ; call kernel to perform the interrupt (output string)
    81                                  b2:   
    82                                     ; now read the major
    83 0000005E BA50000000                  mov edx, 80            ; max chars to read
    84 00000063 B9[22000000]                mov ecx, our_major     ; where to store input value
    85 00000068 BB02000000                  mov ebx, 2             ; where to read from (stdin)
    86 0000006D B803000000                  mov eax, 3             ; read 
    87 00000072 CD80                        int 0x80        ; call kernel to perform the interrupt (input string)
    88                                    
    89 00000074 48                          dec eax                ; don't count newline
    90 00000075 A3[72000000]                mov dword [major_len], eax  
    91                                  
    92                                    ; write our first prompt string to stdout
    93 0000007A BA10000000                  mov edx,len2             ;  message length
    94 0000007F B9[21000000]                mov ecx,welcome_msg      ; second argument: pointer to message to write
    95 00000084 BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
    96 00000089 B804000000                  mov eax,4                ;system call number (sys_write)
    97 0000008E CD80                        int 0x80        ; call kernel to perform the interrupt
    98                                   
    99 00000090 8B15[1E000000]              mov edx, dword [name_len]
   100 00000096 B9[00000000]                mov ecx, our_name
   101 0000009B BB01000000                  mov ebx, 1
   102 000000A0 B804000000                  mov eax, 4
   103 000000A5 CD80                        int 0x80        ; call kernel to perform the interrupt
   104                                  
   105                                  
   106                                     
   107                                    ; now print the newline
   108 000000A7 BA01000000                  mov edx, 1      		; 1 character to print
   109 000000AC B9[74000000]                mov ecx, newline            ; load address of character
   110 000000B1 BB01000000                  mov ebx, 1                  ;  ebx = 1
   111 000000B6 B804000000                  mov eax, 4                  ;  eax = 4
   112 000000BB CD80                        int 0x80        ; call kernel to perform the interrupt
   113                                  
   114 000000BD 8B15[72000000]              mov edx, dword [major_len]
   115 000000C3 B9[22000000]                mov ecx, our_major
   116 000000C8 BB01000000                  mov ebx, 1
   117 000000CD B804000000                  mov eax, 4
   118 000000D2 CD80                        int 0x80        ; call kernel to perform the interrupt
   119                                  
   120                                    ; write our first prompt string to stdout
   121 000000D4 BA2F000000                  mov edx,mlen2             ;  message length
   122 000000D9 B9[45000000]                mov ecx,major_msg      ; second argument: pointer to message to write
   123 000000DE BB01000000                  mov ebx,1                ; first argument: file handle (stdout)
   124 000000E3 B804000000                  mov eax,4                ;system call number (sys_write)
   125 000000E8 CD80                        int 0x80        ; call kernel to perform the interrupt
   126                                   
   127                                  
   128                                    ; now print the newline
   129 000000EA BA01000000                  mov edx, 1      		; 1 character to print
   130 000000EF B9[74000000]                mov ecx, newline            ; load address of character
   131 000000F4 BB01000000                  mov ebx, 1                  ;  ebx = 1
   132 000000F9 B804000000                  mov eax, 4                  ;  eax = 4
   133 000000FE CD80                        int 0x80        ; call kernel to perform the interrupt
   134                                  
   135                                    ; now exit the program    
   136 00000100 BB00000000                  mov ebx, 0       		; the stop interrupt
   137 00000105 B801000000                  mov eax, 1                  ; eax = 0, ebx = 1
   138 0000010A CD80                        int 0x80        ; call kernel to perform the interrupt (stop)
